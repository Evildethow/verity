// Code generated by protoc-gen-go. DO NOT EDIT.
// source: draftspecs/messagingspec/stream.proto

package messagingspec

import (
	context "context"
	fmt "fmt"
	envelopespec "github.com/dogmatiq/infix/draftspecs/envelopespec"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ConsumeRequest struct {
	// ApplicationKey is the identity key of the application to consume from.
	ApplicationKey string `protobuf:"bytes,1,opt,name=application_key,json=applicationKey,proto3" json:"application_key,omitempty"`
	// Offset is the offset of the earliest message to be consumed.
	//
	// The offset of the message returned will be greater than this value if the
	// event at that offset is one of the requested message types.
	Offset uint64 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// types is the set of message types to include in the results.
	Types                []string `protobuf:"bytes,3,rep,name=types,proto3" json:"types,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsumeRequest) Reset()         { *m = ConsumeRequest{} }
func (m *ConsumeRequest) String() string { return proto.CompactTextString(m) }
func (*ConsumeRequest) ProtoMessage()    {}
func (*ConsumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_31fe336c3af87128, []int{0}
}

func (m *ConsumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsumeRequest.Unmarshal(m, b)
}
func (m *ConsumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsumeRequest.Marshal(b, m, deterministic)
}
func (m *ConsumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumeRequest.Merge(m, src)
}
func (m *ConsumeRequest) XXX_Size() int {
	return xxx_messageInfo_ConsumeRequest.Size(m)
}
func (m *ConsumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumeRequest proto.InternalMessageInfo

func (m *ConsumeRequest) GetApplicationKey() string {
	if m != nil {
		return m.ApplicationKey
	}
	return ""
}

func (m *ConsumeRequest) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ConsumeRequest) GetTypes() []string {
	if m != nil {
		return m.Types
	}
	return nil
}

type ConsumeResponse struct {
	// Offset is the offset of the message.
	//
	// It will be greater than the offset provided in the ConsumeRequest if the
	// event at the requested offset was one fo the requested message types.
	Offset uint64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// Envelope is the envelope containing the event.
	Envelope             *envelopespec.Envelope `protobuf:"bytes,2,opt,name=envelope,proto3" json:"envelope,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ConsumeResponse) Reset()         { *m = ConsumeResponse{} }
func (m *ConsumeResponse) String() string { return proto.CompactTextString(m) }
func (*ConsumeResponse) ProtoMessage()    {}
func (*ConsumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_31fe336c3af87128, []int{1}
}

func (m *ConsumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsumeResponse.Unmarshal(m, b)
}
func (m *ConsumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsumeResponse.Marshal(b, m, deterministic)
}
func (m *ConsumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumeResponse.Merge(m, src)
}
func (m *ConsumeResponse) XXX_Size() int {
	return xxx_messageInfo_ConsumeResponse.Size(m)
}
func (m *ConsumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumeResponse proto.InternalMessageInfo

func (m *ConsumeResponse) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ConsumeResponse) GetEnvelope() *envelopespec.Envelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

func init() {
	proto.RegisterType((*ConsumeRequest)(nil), "dogma.messaging.v1.ConsumeRequest")
	proto.RegisterType((*ConsumeResponse)(nil), "dogma.messaging.v1.ConsumeResponse")
}

func init() {
	proto.RegisterFile("draftspecs/messagingspec/stream.proto", fileDescriptor_31fe336c3af87128)
}

var fileDescriptor_31fe336c3af87128 = []byte{
	// 316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x51, 0xcf, 0x4b, 0xfb, 0x30,
	0x1c, 0x25, 0xdf, 0x7d, 0x9d, 0x2e, 0x83, 0x0d, 0x82, 0xc8, 0x98, 0x97, 0x31, 0xd1, 0x15, 0x84,
	0xd4, 0x4d, 0xc1, 0xbb, 0xb2, 0x93, 0x78, 0xa9, 0x3b, 0x79, 0x19, 0x59, 0xf7, 0x69, 0x0d, 0xae,
	0x49, 0xd6, 0xa4, 0xc5, 0xfe, 0x7f, 0xfe, 0x61, 0xb2, 0xa4, 0x2d, 0x1d, 0x3a, 0xbd, 0xf5, 0x95,
	0xf7, 0x23, 0xef, 0x7d, 0xf0, 0xe5, 0x3a, 0x65, 0x91, 0xd1, 0x0a, 0x42, 0xed, 0x27, 0xa0, 0x35,
	0x8b, 0xb9, 0x88, 0x77, 0xd0, 0xd7, 0x26, 0x05, 0x96, 0x50, 0x95, 0x4a, 0x23, 0x09, 0x59, 0xcb,
	0x38, 0x61, 0xb4, 0x66, 0xd0, 0x7c, 0x3a, 0xbc, 0x6a, 0x48, 0x41, 0xe4, 0xb0, 0x91, 0x0a, 0xac,
	0xb2, 0x02, 0x4e, 0x3b, 0xbc, 0x3e, 0x18, 0xe1, 0x10, 0x98, 0x42, 0x81, 0x76, 0xe4, 0x71, 0x8c,
	0x7b, 0x8f, 0x52, 0xe8, 0x2c, 0x81, 0x00, 0xb6, 0x19, 0x68, 0x43, 0x26, 0xb8, 0xcf, 0x94, 0xda,
	0xf0, 0x90, 0x19, 0x2e, 0xc5, 0xf2, 0x1d, 0x8a, 0x01, 0x1a, 0x21, 0xaf, 0x13, 0xf4, 0x1a, 0xbf,
	0x9f, 0xa0, 0x20, 0x67, 0xb8, 0x2d, 0xa3, 0x48, 0x83, 0x19, 0xfc, 0x1b, 0x21, 0xef, 0x7f, 0x50,
	0x22, 0x72, 0x8a, 0x8f, 0x6c, 0xc2, 0xa0, 0x35, 0x6a, 0x79, 0x9d, 0xc0, 0x81, 0xf1, 0x0a, 0xf7,
	0xeb, 0x20, 0xad, 0xa4, 0xd0, 0xd0, 0x30, 0x40, 0x7b, 0x06, 0xf7, 0xf8, 0xa4, 0xaa, 0x64, 0xad,
	0xbb, 0xb3, 0x73, 0xea, 0xf6, 0xa8, 0x9b, 0xe6, 0x53, 0x3a, 0x2f, 0xbf, 0x83, 0x9a, 0x3c, 0xfb,
	0x44, 0xb8, 0x3b, 0xcf, 0x41, 0x98, 0x17, 0xbb, 0x25, 0x59, 0xe0, 0xe3, 0x32, 0x93, 0x8c, 0xe9,
	0xf7, 0x45, 0xe9, 0x7e, 0xf3, 0xe1, 0xc5, 0xaf, 0x1c, 0xf7, 0xe8, 0x1b, 0x44, 0x96, 0x18, 0xdb,
	0x90, 0xc5, 0xae, 0x17, 0x99, 0xfc, 0x24, 0x7a, 0x76, 0x43, 0x5b, 0x46, 0xe5, 0xee, 0xfd, 0x4d,
	0x74, 0x11, 0x0f, 0x77, 0xaf, 0xb3, 0x98, 0x9b, 0xb7, 0x6c, 0x45, 0x43, 0x99, 0xf8, 0x56, 0x65,
	0xf8, 0xd6, 0xe7, 0x22, 0xe2, 0x1f, 0xfe, 0xa1, 0xe3, 0xae, 0xda, 0xf6, 0xa0, 0xb7, 0x5f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0xb7, 0x42, 0x42, 0x68, 0x62, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// EventStreamClient is the client API for EventStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventStreamClient interface {
	// Consume starts consuming from an application's event stream.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	//
	// If the requested offset is beyond the end of the application's event
	// stream, the server SHOULD keep the stream open, sending the messages as
	// they become available.
	//
	// If any of the message types are not produced by the specified application
	// the server MUST return an INVALID_ARGUMENT error with an attached
	// UnrecognizedMessage value for each unrecognized message type.
	Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (EventStream_ConsumeClient, error)
	// EventTypes queries the event types that the server supports for a specific
	// application.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	EventTypes(ctx context.Context, in *MessageTypesRequest, opts ...grpc.CallOption) (*MessageTypesResponse, error)
}

type eventStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewEventStreamClient(cc grpc.ClientConnInterface) EventStreamClient {
	return &eventStreamClient{cc}
}

func (c *eventStreamClient) Consume(ctx context.Context, in *ConsumeRequest, opts ...grpc.CallOption) (EventStream_ConsumeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventStream_serviceDesc.Streams[0], "/dogma.messaging.v1.EventStream/Consume", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventStreamConsumeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventStream_ConsumeClient interface {
	Recv() (*ConsumeResponse, error)
	grpc.ClientStream
}

type eventStreamConsumeClient struct {
	grpc.ClientStream
}

func (x *eventStreamConsumeClient) Recv() (*ConsumeResponse, error) {
	m := new(ConsumeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventStreamClient) EventTypes(ctx context.Context, in *MessageTypesRequest, opts ...grpc.CallOption) (*MessageTypesResponse, error) {
	out := new(MessageTypesResponse)
	err := c.cc.Invoke(ctx, "/dogma.messaging.v1.EventStream/EventTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventStreamServer is the server API for EventStream service.
type EventStreamServer interface {
	// Consume starts consuming from an application's event stream.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	//
	// If the requested offset is beyond the end of the application's event
	// stream, the server SHOULD keep the stream open, sending the messages as
	// they become available.
	//
	// If any of the message types are not produced by the specified application
	// the server MUST return an INVALID_ARGUMENT error with an attached
	// UnrecognizedMessage value for each unrecognized message type.
	Consume(*ConsumeRequest, EventStream_ConsumeServer) error
	// EventTypes queries the event types that the server supports for a specific
	// application.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	EventTypes(context.Context, *MessageTypesRequest) (*MessageTypesResponse, error)
}

// UnimplementedEventStreamServer can be embedded to have forward compatible implementations.
type UnimplementedEventStreamServer struct {
}

func (*UnimplementedEventStreamServer) Consume(req *ConsumeRequest, srv EventStream_ConsumeServer) error {
	return status.Errorf(codes.Unimplemented, "method Consume not implemented")
}
func (*UnimplementedEventStreamServer) EventTypes(ctx context.Context, req *MessageTypesRequest) (*MessageTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventTypes not implemented")
}

func RegisterEventStreamServer(s *grpc.Server, srv EventStreamServer) {
	s.RegisterService(&_EventStream_serviceDesc, srv)
}

func _EventStream_Consume_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsumeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventStreamServer).Consume(m, &eventStreamConsumeServer{stream})
}

type EventStream_ConsumeServer interface {
	Send(*ConsumeResponse) error
	grpc.ServerStream
}

type eventStreamConsumeServer struct {
	grpc.ServerStream
}

func (x *eventStreamConsumeServer) Send(m *ConsumeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EventStream_EventTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventStreamServer).EventTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dogma.messaging.v1.EventStream/EventTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventStreamServer).EventTypes(ctx, req.(*MessageTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dogma.messaging.v1.EventStream",
	HandlerType: (*EventStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EventTypes",
			Handler:    _EventStream_EventTypes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Consume",
			Handler:       _EventStream_Consume_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "draftspecs/messagingspec/stream.proto",
}
