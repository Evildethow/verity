// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internal/draftspecs/messagingspec/queue.proto

package messagingspec

import (
	context "context"
	fmt "fmt"
	envelopespec "github.com/dogmatiq/infix/internal/draftspecs/envelopespec"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EnqueueRequest struct {
	// ApplicationKey is the identity key of the application that handles the
	// command.
	ApplicationKey string `protobuf:"bytes,1,opt,name=application_key,json=applicationKey,proto3" json:"application_key,omitempty"`
	// Envelope is the envelope containing the command to be executed.
	Envelope             *envelopespec.Envelope `protobuf:"bytes,2,opt,name=envelope,proto3" json:"envelope,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EnqueueRequest) Reset()         { *m = EnqueueRequest{} }
func (m *EnqueueRequest) String() string { return proto.CompactTextString(m) }
func (*EnqueueRequest) ProtoMessage()    {}
func (*EnqueueRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_060dee6d6bcf67d1, []int{0}
}

func (m *EnqueueRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnqueueRequest.Unmarshal(m, b)
}
func (m *EnqueueRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnqueueRequest.Marshal(b, m, deterministic)
}
func (m *EnqueueRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnqueueRequest.Merge(m, src)
}
func (m *EnqueueRequest) XXX_Size() int {
	return xxx_messageInfo_EnqueueRequest.Size(m)
}
func (m *EnqueueRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnqueueRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnqueueRequest proto.InternalMessageInfo

func (m *EnqueueRequest) GetApplicationKey() string {
	if m != nil {
		return m.ApplicationKey
	}
	return ""
}

func (m *EnqueueRequest) GetEnvelope() *envelopespec.Envelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

type EnqueueResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnqueueResponse) Reset()         { *m = EnqueueResponse{} }
func (m *EnqueueResponse) String() string { return proto.CompactTextString(m) }
func (*EnqueueResponse) ProtoMessage()    {}
func (*EnqueueResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_060dee6d6bcf67d1, []int{1}
}

func (m *EnqueueResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnqueueResponse.Unmarshal(m, b)
}
func (m *EnqueueResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnqueueResponse.Marshal(b, m, deterministic)
}
func (m *EnqueueResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnqueueResponse.Merge(m, src)
}
func (m *EnqueueResponse) XXX_Size() int {
	return xxx_messageInfo_EnqueueResponse.Size(m)
}
func (m *EnqueueResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EnqueueResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EnqueueResponse proto.InternalMessageInfo

type AckRequest struct {
	// ApplicationKey is the identity key of the application that produced the
	// command.
	ApplicationKey string `protobuf:"bytes,1,opt,name=application_key,json=applicationKey,proto3" json:"application_key,omitempty"`
	// MessageID is the command message's unique identifier.
	MessageId            string   `protobuf:"bytes,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckRequest) Reset()         { *m = AckRequest{} }
func (m *AckRequest) String() string { return proto.CompactTextString(m) }
func (*AckRequest) ProtoMessage()    {}
func (*AckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_060dee6d6bcf67d1, []int{2}
}

func (m *AckRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AckRequest.Unmarshal(m, b)
}
func (m *AckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AckRequest.Marshal(b, m, deterministic)
}
func (m *AckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckRequest.Merge(m, src)
}
func (m *AckRequest) XXX_Size() int {
	return xxx_messageInfo_AckRequest.Size(m)
}
func (m *AckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AckRequest proto.InternalMessageInfo

func (m *AckRequest) GetApplicationKey() string {
	if m != nil {
		return m.ApplicationKey
	}
	return ""
}

func (m *AckRequest) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

type AckResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckResponse) Reset()         { *m = AckResponse{} }
func (m *AckResponse) String() string { return proto.CompactTextString(m) }
func (*AckResponse) ProtoMessage()    {}
func (*AckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_060dee6d6bcf67d1, []int{3}
}

func (m *AckResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AckResponse.Unmarshal(m, b)
}
func (m *AckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AckResponse.Marshal(b, m, deterministic)
}
func (m *AckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckResponse.Merge(m, src)
}
func (m *AckResponse) XXX_Size() int {
	return xxx_messageInfo_AckResponse.Size(m)
}
func (m *AckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AckResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*EnqueueRequest)(nil), "dogma.messaging.v1.EnqueueRequest")
	proto.RegisterType((*EnqueueResponse)(nil), "dogma.messaging.v1.EnqueueResponse")
	proto.RegisterType((*AckRequest)(nil), "dogma.messaging.v1.AckRequest")
	proto.RegisterType((*AckResponse)(nil), "dogma.messaging.v1.AckResponse")
}

func init() {
	proto.RegisterFile("internal/draftspecs/messagingspec/queue.proto", fileDescriptor_060dee6d6bcf67d1)
}

var fileDescriptor_060dee6d6bcf67d1 = []byte{
	// 341 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0x4d, 0x4f, 0xf2, 0x40,
	0x10, 0x0e, 0xbc, 0xc9, 0xab, 0x0c, 0x08, 0x71, 0x4f, 0xa4, 0x46, 0x25, 0xf5, 0x00, 0x17, 0xb7,
	0x01, 0x4d, 0x3c, 0x18, 0x0f, 0x68, 0x30, 0x31, 0xc6, 0x83, 0x0d, 0x27, 0x2f, 0x64, 0x69, 0x87,
	0xba, 0x81, 0xee, 0x2e, 0xdd, 0x2d, 0x91, 0x1f, 0xe1, 0x7f, 0x36, 0x74, 0x4b, 0xc5, 0x88, 0x12,
	0x6f, 0x9d, 0xe9, 0x33, 0xcf, 0xc7, 0xce, 0xc0, 0x39, 0x17, 0x06, 0x13, 0xc1, 0x66, 0x5e, 0x98,
	0xb0, 0x89, 0xd1, 0x0a, 0x03, 0xed, 0xc5, 0xa8, 0x35, 0x8b, 0xb8, 0x88, 0x56, 0xa5, 0x37, 0x4f,
	0x31, 0x45, 0xaa, 0x12, 0x69, 0x24, 0x21, 0xa1, 0x8c, 0x62, 0x46, 0x0b, 0x00, 0x5d, 0x74, 0x1d,
	0x6f, 0x1b, 0x05, 0x8a, 0x05, 0xce, 0xa4, 0xc2, 0x8c, 0x61, 0x5d, 0x58, 0x12, 0xe7, 0x72, 0xb7,
	0xa6, 0xad, 0xd0, 0x2c, 0x15, 0x6a, 0x3b, 0xe5, 0x26, 0x50, 0x1f, 0x88, 0xcc, 0x8b, 0x8f, 0xf3,
	0x14, 0xb5, 0x21, 0x6d, 0x68, 0x30, 0xa5, 0x66, 0x3c, 0x60, 0x86, 0x4b, 0x31, 0x9a, 0xe2, 0xb2,
	0x59, 0x6a, 0x95, 0x3a, 0x15, 0xbf, 0xbe, 0xd1, 0x7e, 0xc4, 0x25, 0xb9, 0x82, 0xfd, 0xb5, 0x85,
	0x66, 0xb9, 0x55, 0xea, 0x54, 0x7b, 0x47, 0xd4, 0x06, 0x29, 0x9c, 0x2d, 0xba, 0x74, 0x90, 0x7f,
	0xfb, 0x05, 0xd8, 0x3d, 0x84, 0x46, 0xa1, 0xa9, 0x95, 0x14, 0x1a, 0xdd, 0x21, 0x40, 0x3f, 0x98,
	0xfe, 0xd9, 0xc2, 0x31, 0x40, 0x9e, 0x69, 0xc4, 0xc3, 0xcc, 0x44, 0xc5, 0xaf, 0xe4, 0x9d, 0x87,
	0xd0, 0x3d, 0x80, 0x6a, 0xc6, 0x6a, 0x45, 0x7a, 0xef, 0x65, 0xa8, 0xdd, 0xc9, 0x38, 0x66, 0x22,
	0x7c, 0x5e, 0xa9, 0x13, 0x1f, 0xf6, 0x72, 0x23, 0xc4, 0xa5, 0xdf, 0x77, 0x40, 0xbf, 0xbe, 0x8c,
	0x73, 0xf6, 0x2b, 0xc6, 0x8a, 0x90, 0x7b, 0xf8, 0xd7, 0x0f, 0xa6, 0xe4, 0x64, 0x1b, 0xf6, 0x33,
	0xa2, 0x73, 0xfa, 0xe3, 0xff, 0x9c, 0x87, 0x41, 0xed, 0xc9, 0x06, 0x19, 0xae, 0xd6, 0x45, 0xda,
	0xdb, 0x06, 0x36, 0x11, 0x6b, 0xe6, 0xce, 0x6e, 0xa0, 0x95, 0xb8, 0xbd, 0x79, 0xb9, 0x8e, 0xb8,
	0x79, 0x4d, 0xc7, 0x34, 0x90, 0xb1, 0x97, 0x4d, 0x19, 0x3e, 0xf7, 0xb8, 0x98, 0xf0, 0x37, 0x6f,
	0xe7, 0x35, 0x8d, 0xff, 0x67, 0x17, 0x74, 0xf1, 0x11, 0x00, 0x00, 0xff, 0xff, 0x4b, 0xb1, 0x12,
	0x5c, 0xed, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CommandQueueClient is the client API for CommandQueue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommandQueueClient interface {
	// Enqueue adds a message to the inbound command queue.
	//
	// The client is an engine with a message on its outbound queue. The server is
	// an engine that hosts an application that can handle commands of that type.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	//
	// If the server does not handle messages of the type provided in the request,
	// it MUST return an INVALID_ARGUMENT error with an attached
	// UnrecognizedMessage value.
	//
	// The server MUST keep the enqueued message on its inbound queue until it
	// removes the message from the client's outbound queue by calling Ack(). The
	// mechanism for determining how to dial back to the client is engine-specific
	// and outside the scope of this specification.
	//
	// If the message in the request, identified by the message ID, is not already
	// on the queue, it is added. A successful response MUST be returned
	// regardless of whether the message was already enqueued or not.
	//
	// The client SHOULD retry the Enqueue() oepration until it receives a
	// successful response, or until it receives an Ack() call for the message.
	Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error)
	// Ack removes a message from the outbound command queue.
	//
	// The client is an engine that has enqueued (and potentially already
	// executed) a message received via a prior call to Enqueue().
	//
	// If the message specified in the request is still on the outbound queue, it
	// is removed. A successful response MUST be returned regardless of whether
	// the message was still enqueued or not.
	//
	// Upon returning a successful response, the server MUST NOT make any future
	// call to Enqueue() for the specified message.
	Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error)
	// MessageTypes queries the messages types that the server supports for a
	// specific application.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	MessageTypes(ctx context.Context, in *MessageTypesRequest, opts ...grpc.CallOption) (*MessageTypesResponse, error)
}

type commandQueueClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandQueueClient(cc grpc.ClientConnInterface) CommandQueueClient {
	return &commandQueueClient{cc}
}

func (c *commandQueueClient) Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error) {
	out := new(EnqueueResponse)
	err := c.cc.Invoke(ctx, "/dogma.messaging.v1.CommandQueue/Enqueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandQueueClient) Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, "/dogma.messaging.v1.CommandQueue/Ack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandQueueClient) MessageTypes(ctx context.Context, in *MessageTypesRequest, opts ...grpc.CallOption) (*MessageTypesResponse, error) {
	out := new(MessageTypesResponse)
	err := c.cc.Invoke(ctx, "/dogma.messaging.v1.CommandQueue/MessageTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandQueueServer is the server API for CommandQueue service.
type CommandQueueServer interface {
	// Enqueue adds a message to the inbound command queue.
	//
	// The client is an engine with a message on its outbound queue. The server is
	// an engine that hosts an application that can handle commands of that type.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	//
	// If the server does not handle messages of the type provided in the request,
	// it MUST return an INVALID_ARGUMENT error with an attached
	// UnrecognizedMessage value.
	//
	// The server MUST keep the enqueued message on its inbound queue until it
	// removes the message from the client's outbound queue by calling Ack(). The
	// mechanism for determining how to dial back to the client is engine-specific
	// and outside the scope of this specification.
	//
	// If the message in the request, identified by the message ID, is not already
	// on the queue, it is added. A successful response MUST be returned
	// regardless of whether the message was already enqueued or not.
	//
	// The client SHOULD retry the Enqueue() oepration until it receives a
	// successful response, or until it receives an Ack() call for the message.
	Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error)
	// Ack removes a message from the outbound command queue.
	//
	// The client is an engine that has enqueued (and potentially already
	// executed) a message received via a prior call to Enqueue().
	//
	// If the message specified in the request is still on the outbound queue, it
	// is removed. A successful response MUST be returned regardless of whether
	// the message was still enqueued or not.
	//
	// Upon returning a successful response, the server MUST NOT make any future
	// call to Enqueue() for the specified message.
	Ack(context.Context, *AckRequest) (*AckResponse, error)
	// MessageTypes queries the messages types that the server supports for a
	// specific application.
	//
	// If the server does not host the application specified in the request, it
	// MUST return a NOT_FOUND error with an attached UnrecognizedApplication
	// value.
	MessageTypes(context.Context, *MessageTypesRequest) (*MessageTypesResponse, error)
}

// UnimplementedCommandQueueServer can be embedded to have forward compatible implementations.
type UnimplementedCommandQueueServer struct {
}

func (*UnimplementedCommandQueueServer) Enqueue(ctx context.Context, req *EnqueueRequest) (*EnqueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enqueue not implemented")
}
func (*UnimplementedCommandQueueServer) Ack(ctx context.Context, req *AckRequest) (*AckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ack not implemented")
}
func (*UnimplementedCommandQueueServer) MessageTypes(ctx context.Context, req *MessageTypesRequest) (*MessageTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageTypes not implemented")
}

func RegisterCommandQueueServer(s *grpc.Server, srv CommandQueueServer) {
	s.RegisterService(&_CommandQueue_serviceDesc, srv)
}

func _CommandQueue_Enqueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandQueueServer).Enqueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dogma.messaging.v1.CommandQueue/Enqueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandQueueServer).Enqueue(ctx, req.(*EnqueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandQueue_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandQueueServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dogma.messaging.v1.CommandQueue/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandQueueServer).Ack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandQueue_MessageTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandQueueServer).MessageTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dogma.messaging.v1.CommandQueue/MessageTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandQueueServer).MessageTypes(ctx, req.(*MessageTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandQueue_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dogma.messaging.v1.CommandQueue",
	HandlerType: (*CommandQueueServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enqueue",
			Handler:    _CommandQueue_Enqueue_Handler,
		},
		{
			MethodName: "Ack",
			Handler:    _CommandQueue_Ack_Handler,
		},
		{
			MethodName: "MessageTypes",
			Handler:    _CommandQueue_MessageTypes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/draftspecs/messagingspec/queue.proto",
}
